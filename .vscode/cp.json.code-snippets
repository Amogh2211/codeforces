{
    // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
    // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
    // same ids are connected.
    // Example:
    // "Print to console": {
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
    "fie": {"prefix": "fie", "body": "for (${3:i} = ${4:0}; ${3:i} < ${2:n}; ++${3:i})$1"},
    "fiei": {"prefix": "fiei", "body": "for (int ${3:i} = ${4:0}; ${3:i} < ${2:n}; ++${3:i})$1"},
    "fiii": {"prefix": "fiii", "body": "for (int ${3:i} = ${4:1}; ${3:i} <= ${2:n}; ++${3:i})$1"},
    "long": {"prefix": "ll", "body": "long"},
    "string": {"prefix": "sr", "body": "string"},

    "vector<int>": {"prefix": "vi", "body": "vector<int>"},
    "vector<long>": {"prefix": "vl", "body": "vector<long>"},
    "vector<char>": {"prefix": "vc", "body": "vector<char>"},
    "vector<bool>": {"prefix": "vb", "body": "vector<bool>"},
    "vector<string>": {"prefix": "vs", "body": "vector<string>"},

    "vector<vector<int>>": {"prefix": "vvi", "body": "vector<vector<int>>"},
    "vector<vector<long>>": {"prefix": "vvl", "body": "vector<vector<long>>"},
    "vector<vector<char>>": {"prefix": "vvc", "body": "vector<vector<char>>"},
    "vector<vector<string>>": {"prefix": "vvs", "body": "vector<vector<string>>"},

    "pair<int, int>": {"prefix": "pii", "body": "pair<int, int>"},
    "pair<long, long>": {"prefix": "pll", "body": "pair<long, long>"},
    "pair<char, char>": {"prefix": "pcc", "body": "pair<char, char>"},
    "pair<string, string>": {"prefix": "pss", "body": "pair<string, string>"},
    "pair<int, char>": {"prefix": "pic", "body": "pair<int, char>"},
    "pair<char, int>": {"prefix": "pci", "body": "pair<char, int>"},
    "pair<int, string>": {"prefix": "pis", "body": "pair<int, string>"},
    "pair<string, int>": {"prefix": "psi", "body": "pair<string, int>"},

    "pair<pair<int, int>, int>>": {"prefix": "ppiii", "body": "pair<pair<int, int>, int>>"},
    "pair<int, pair<int, int>>": {"prefix": "pipii", "body": "pair<int, pair<int, int>>"},
    "pair<pair<long, long>, long>>": {"prefix": "pplll", "body": "pair<pair<long, long>, long>>"},
    "pair<long, pair<long, long>>": {"prefix": "plpll", "body": "pair<long, pair<long, long>>"},

    "vector<pair<int, int>>": {"prefix": "vpii", "body": "vector<pair<int, int>>"},
    "vector<pair<long, long>>": {"prefix": "vpll", "body": "vector<pair<long, long>>"},

    "vector<pair<pair<int, int>, int>>": {"prefix": "vppiii", "body": "vector<pair<pair<int, int>, int>>>"},
    "vector<pair<int, pair<int, int>>>": {"prefix": "vpipii", "body": "vector<pair<int, pair<int, int>>>"},
    "vector<pair<pair<long, long>, long>>>": {"prefix": "vpplll", "body": "vector<pair<pair<long, long>, long>>>"},
    "vector<pair<long, pair<long, long>>>": {"prefix": "vplpll", "body": "vector<pair<long, pair<long, long>>>"},

    "set<int>": {"prefix": "si", "body": "set<int>"},
    "set<long>": {"prefix": "sl", "body": "set<long>"},
    "set<char>": {"prefix": "sc", "body": "set<char>"},
    "set<string>": {"prefix": "ssr", "body": "set<string>"},
    "set<pair<int, int>>": {"prefix": "spii", "body": "set<pair<int, int>>"},
    "set<pair<long, long>>": {"prefix": "spll", "body": "set<pair<long, long>>"},

    "map<int, int>": {"prefix": "mii", "body": "map<int, int>"},
    "map<long, long>": {"prefix": "mll", "body": "map<long, long>"},
    "map<int, long>": {"prefix": "mil", "body": "map<int, long>"},
    "map<long, int>": {"prefix": "mli", "body": "map<long, int>"},
    "map<string, int>": {"prefix": "msi", "body": "map<string, int>"},
    "map<string, long>": {"prefix": "msl", "body": "map<string, long>"},
    "map<int, set<int>>": {"prefix": "misi", "body": "map<int, set<int>>"},
    "map<int, vector<int>>": {"prefix": "mivi", "body": "map<int, vector<int>>"},
    "map<pair<int, int>, int>": {"prefix": "mpiii", "body": "map<pair<int, int>, int>"},
    "map<int, pair<int, int>>": {"prefix": "mipii", "body": "map<int, pair<int, int>>"},

    "first": {"prefix": "ff", "body": "first"},
    "second": {"prefix": "ss", "body": "second"},
    "greater": {"prefix": "gr", "body": "greater<>"},
    "size": {"prefix": "sz", "body": "size()"},
    "push_back": {"prefix": "pb", "body": "push_back($1)"},
    "emplace_back": {"prefix": "eb", "body": "emplace_back($1)"},
    "push_front": {"prefix": "pf", "body": "push_front($1)"},
    "insert": {"prefix": "in", "body": "insert($1)"},
    "erase": {"prefix": "er", "body": "erase($1)"},
    "lower_bound": {"prefix": "lb", "body": "lower_bound($1)"},
    "upper_bound": {"prefix": "ub", "body": "upper_bound($1)"},

    "Declare array": {"prefix": "cn", "body": "const int N = ${1:3e5} + 5;"},
    "Modulo": {"prefix": "cmod", "body": "const int MOD = 1000000007;"},
    "Modulo2": {"prefix": "cmod2", "body": "const int MOD = 998244353;"},
    "Infinity": {"prefix": "cinf", "body": "const int INF = 0x3fffffff;"},
    "Infinity2": {"prefix": "cinf2", "body": "const long INF = (1LL << 62) - 1;"},
    "Pi": {"prefix": "cpi", "body": "const double PI = 3.1415926535898;"},
    "Epsilon": {"prefix": "ceps", "body": "const double EPS = 1e-8;"},
    "Max integer": {"prefix": "IM", "body": "INT_MAX"},
    "Max long": {"prefix": "LLM", "body": "LONG_LONG_MAX"},

    "newline": {"prefix": "nl", "body": "<< '\\n'"},
    "return": {"prefix": "ret", "body": "return"},
    "setprecision": {"prefix": "setprec", "body": "cout << fixed << setprecision(12)"},
    "Print runtime": {"prefix": "clock", "body": "cerr << \"\\nCompleted in \" << 1000 * clock() / CLOCKS_PER_SEC << \" ms\\n\";"},
    "Debug": {"prefix": "dbg", "body": "cerr << \"$1: \" << $1 << endl;"},
    "Meow": {"prefix": "meow", "body": "cerr << ${1:\"Meow\"} << endl;"},
    "popcount": {"prefix": "bpc", "body": "__builtin_popcountll($1)"},
    "popcount?": {"prefix": "bclz", "body": "__builtin_clzll($1)"},
    "ffs": {"prefix": "bffs", "body": "__builtin_ffsll($1)"},
    "Ceiling division": {"prefix": "cdiv", "body": "$1/$2 + bool($1%$2)"},
    "floor": {"prefix": "floor", "body": "llround(floor($1))"},
    "ceil": {"prefix": "ceil", "body": "llround(ceil($1))"},
    "memset": {"prefix": "memset", "body": "memset($1, $2, sizeof($1));"},
    "cout and return": {"prefix": "rc", "body": "return cout << $1, 0;"},
    "Case #t:": {"prefix": "tcase", "body": "cout << \"Case #\" << t << \": \" << "},

    "Fast IO": {"prefix": "fastio", "body": "ios::sync_with_stdio(false), cin.tie(nullptr);"},
    "Begin End": {"prefix": "bend", "body": "$1.begin(), $1.end()"},
    "Yes/No": {"prefix": "yesno", "body": "cout << ($1 ? \"YES\" : \"NO\") << '\\n';"},

    {
        // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
        // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
        // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
        // same ids are connected.
        // Example:
        // "Print to console": {
        // 	"prefix": "log",
        // 	"body": [
        // 		"console.log('$1');",
        // 		"$2"
        // 	],
        // 	"description": "Log output to console"
        // }
        "main": {
            "prefix": "cpp",
            "body": [
                "// Author: #############",
                "",
                "#include <bits/stdc++.h>",
                "using namespace std;",
                "#define long int64_t",
                "",
                "int main()",
                "{",
                "    int n$1;",
                "    cin >> n;",
                "    return 0;",
                "}",
                "",
            ]
        },
        "main2": {
            "prefix": "cppt",
            "body": [
                "// Author: #############",
                "",
                "#include <bits/stdc++.h>",
                "using namespace std;",
                "#define long int64_t",
                "",
                "void solve()",
                "{",
                "    int n$1;",
                "    cin >> n;",
                "    $2",
                "}",
                "",
                "int main()",
                "{",
                "    ios::sync_with_stdio(false), cin.tie(nullptr);",
                "    int T;",
                "    cin >> T;",
                "    while (T--) {",
                "        solve();",
                "    }",
                "    return 0;",
                "}",
                "",
            ]
        },
        "BFS": {
            "prefix": "bfs",
            "body": [
                "void bfs(int u = 1)",
                "{",
                "    vector<int> ways(n+1), dist(n+1);",
                "    vector<bool> bvis(n+1);",
                "    queue<int> q;",
                "    q.push(u);",
                "    ways[u] = 1;",
                "    dist[u] = 1;",
                "    while(q.size())",
                "    {",
                "        u = q.front(), q.pop();",
                "        for(int v : g[u])",
                "        {",
                "            if(bvis[v])",
                "            {",
                "                if(dist[v] == dist[u] + 1)",
                "                    ways[v] += ways[u];",
                "            }",
                "            else",
                "            {",
                "                dist[v] = dist[u] + 1;",
                "                ways[v] += ways[u];",
                "                bvis[v] = 1;",
                "                q.push(v);",
                "                $1",
                "            }",
                "        }",
                "    }",
                "}",
            ]
        },
        "Binary Search (Float)": {
            "prefix": "floatbinsearch",
            "body": [
                "double binsearch(double lo, double hi)",
                "{",
                "    while(hi - lo > eps)",
                "    {",
                "        double mid = lo + (hi-lo)/2;",
                "        if(check(mid))",
                "            lo = mid;",
                "        else",
                "            hi = mid;",
                "    }",
                "    return lo;",
                "}",
            ]
        },
        "Binary Search (Integer)": {
            "prefix": "binsearch",
            "body": [
                "bool check(long x)",
                "{",
                "    return 0;",
                "}",
                "",
                "long binsearch(long lo, long hi)",
                "{",
                "    while(lo <= hi)",
                "    {",
                "        long mid = lo + (hi-lo)/2;",
                "        if(check(mid))",
                "            lo = mid + 1;",
                "        else",
                "            hi = mid - 1;",
                "    }",
                "    return hi;",
                "}",
            ]
        },
        "Choose (nCr)": {
            "prefix": "choose",
            "body": [
                "long choose(int n, int r)",
                "{",
                "    r = min(r, n-r);",
                "    long ans = 1;",
                "    for(int i = 1; i <= r; ++i)",
                "    {",
                "        ans *= n - r + i;",
                "        ans /= i;",
                "    }",
                "    return ans;",
                "}",
            ]
        },
        "Convex Hull": {
            "prefix": "convex",
            "body": [
                "struct Point",
                "{",
                "    long x, y;",
                "",
                "    Point(long x, long y): x(x), y(y) {}",
                "",
                "    void operator =(const Point &p)",
                "    {",
                "        x = p.x, y = p.y;",
                "    }",
                "",
                "    bool operator <(const Point &p)",
                "    {",
                "        if(x == p.x)",
                "            return y < p.y;",
                "        return x < p.x;",
                "    }",
                "",
                "    Point operator +(const Point &p)",
                "    {",
                "        return Point(x + p.x, y + p.y);",
                "    }",
                "",
                "    Point operator -(const Point &p)",
                "    {",
                "        return Point(x - p.x, y - p.y);",
                "    }",
                "",
                "    long dot(const Point &p)",
                "    {",
                "        return x * p.x + y * p.y;",
                "    }",
                "",
                "    long dist()",
                "    {",
                "        return x*x + y*y;",
                "    }",
                "};",
                "",
                "int ornt(Point &a, Point &b, Point &c)",
                "{",
                "    long area = a.x*(b.y-c.y) + b.x*(c.y-a.y) + c.x*(a.y-b.y);",
                "    return (area < 0) - (area > 0);",
                "}",
                "",
                "vector<Point> convex_hull(vector<Point> &v)",
                "{",
                "    if(v.size() < 2)",
                "        return v;",
                "    sort(v.begin(), v.end());",
                "",
                "    Point p1 = v.front(), p2 = v.back();",
                "    vector<Point> up, down;",
                "    up.push_back(p1);",
                "    down.push_back(p1);",
                "",
                "    for(int i = 1; i < v.size(); ++i)",
                "    {",
                "        if(ornt(p1, v[i], p2) > 0 or i == v.size()-1)",
                "        {",
                "            while(up.size() > 1 and ornt(*(up.end()-2), up.back(), v[i]) <= 0)",
                "                up.pop_back();",
                "            up.push_back(v[i]);",
                "        }",
                "        if(ornt(p1, v[i], p2) < 0 or i == v.size()-1)",
                "        {",
                "            while(down.size() > 1 and ornt(*(down.end()-2), down.back(), v[i]) >= 0)",
                "                down.pop_back();",
                "            down.push_back(v[i]);",
                "        }",
                "    }",
                "",
                "    for(int i = down.size()-2; i; i--)",
                "        up.push_back(down[i]);",
                "",
                "    return up;",
                "}",
            ]
        },
        "DFS": {
            "prefix": "dfs",
            "body": [
                "void dfs(int u = 1)",
                "{",
                "    if(vis[u])",
                "        return;",
                "    vis[u] = true;",
                "    for(int v : g[u])",
                "        if(not vis[v])",
                "            dfs(v);",
                "    $1",
                "}",
            ]
        },
        "Dijkstra": {
            "prefix": "dijkstra",
            "body": [
                "vector<int> dijkstra(vector<pair<int, long>> g[], int source, int destination)",
                "{",
                "    vector<long> arrival(N, INF), departure(N, INF);",
                "    vector<int> vis(N), parent(N), ans;",
                "    arrival[source] = 0;",
                "    set<pair<long, int>> s;",
                "    s.insert({0, source});",
                "    while(!s.empty())",
                "    {",
                "        auto [ignore, u] = *s.begin();",
                "        s.erase(s.begin());",
                "        vis[u] = 1;",
                "        departure[u] = arrival[u];",
                "        for(auto [v, w]: g[u])",
                "        {",
                "            if(arrival[v] > departure[u] + w)",
                "            {",
                "                s.erase({arrival[v], v});",
                "                arrival[v] = departure[u] + w;",
                "                s.insert({arrival[v], v});",
                "                parent[v] = u;",
                "            }",
                "        }",
                "    }",
                "    if(!vis[destination])",
                "        return ans;",
                "",
                "    ans.push_back(destination);",
                "    int v = destination;",
                "    while(parent[v])",
                "        ans.push_back(v = parent[v]);",
                "    reverse(ans.begin(), ans.end());",
                "    return ans;",
                "}",
            ]
        },
        "Divisors": {
            "prefix": "divisors",
            "body": [
                "set<long> divisors(long x)",
                "{",
                "    set<long> s;",
                "    for(long i = 1; i*i <= x; ++i)",
                "        if(x % i == 0)",
                "            s.insert(i), s.insert(x/i);",
                "    return s;",
                "}",
            ]
        },
        "DSU": {
            "prefix": "dsu",
            "body": [
                "struct DSU",
                "{",
                "    int parts;",
                "    vector<int> rt, sz;",
                "",
                "    DSU(int n)",
                "    {",
                "        rt.resize(n+1);",
                "        sz.resize(n+1);",
                "        iota(rt.begin(), rt.end(), 0);",
                "        fill(sz.begin(), sz.end(), 1);",
                "        parts = n;",
                "    }",
                "",
                "    int root(int k)",
                "    {",
                "        while(k != rt[k])",
                "            k = rt[k] = rt[rt[k]];",
                "        return k;",
                "    }",
                "",
                "    void merge(int u, int v)",
                "    {",
                "        int r1 = root(u), r2 = root(v);",
                "        if(r1 == r2)",
                "            return;",
                "        parts--;",
                "        if(sz[r1] > sz[r2])",
                "            swap(r1, r2);",
                "        sz[r2] += sz[r1];",
                "        sz[r1] = 0;",
                "        rt[r1] = rt[r2];",
                "    }",
                "};",
            ]
        },
        "Extended GCD": {
            "prefix": "exgcd",
            "body": [
                "long exgcd(long a, long b, long &x, long &y)",
                "{",
                "    if(a == 0)",
                "    {",
                "        x = 0, y = 1;",
                "        return b;",
                "    }",
                "    long x1, y1, g;",
                "    g = exgcd(b % a, a, x1, y1);",
                "    x = y1 - (b/a) * x1;",
                "    y = x1;",
                "    return g;",
                "}",
            ]
        },
        "Factorize": {
            "prefix": "factor",
            "body": [
                "map<long, int> factorize(long x)",
                "{",
                "    long n = x;",
                "    map<long, int> m;",
                "    for(long i = 2; i * i <= n and x > 1; ++i)",
                "        while (x % i == 0)",
                "            m[i]++, x /= i;",
                "    if (x > 1)",
                "        m[x]++;",
                "    return m;",
                "}",
            ]
        },
        "File input output": {
            "prefix": "freopen",
            "body": [
                "#ifndef VICTOR_AUGUR",
                "    freopen(\"input.txt\", \"r\", stdin);",
                "    freopen(\"output.txt\", \"w\", stdout);",
                "#endif",
            ]
        },
        "Graph": {
            "prefix": "graph",
            "body": [
                "struct Graph",
                "{",
                "    vector<vector<int>> g;",
                "    vector<bool> vis;",
                "    int n;",
                "    bool dir;",
                "",
                "    Graph(int vertices, bool directed = 0)",
                "    {",
                "        n = vertices;",
                "        dir = directed;",
                "        g.resize(n + 1);",
                "        vis.resize(n + 1);",
                "    }",
                "",
                "    void in(int edges)",
                "    {",
                "        for(int i = 0; i < edges; ++i) {",
                "            int u, v;",
                "            cin >> u >> v;",
                "            g[u].push_back(v);",
                "            if (not dir)",
                "                g[v].push_back(u);",
                "        }",
                "    }",
                "",
                "    void reset()",
                "    {",
                "        vis.clear();",
                "    }",
                "};",
            ]
        },
        "Polynomial Rolling Hash": {
            "prefix": "polyhash",
            "body": [
                "long modexp(long x, long y, long mod)",
                "{",
                "    long res = 1;",
                "    x = (x % mod + mod) % mod;",
                "    while(y)",
                "    {",
                "        if(y & 1)",
                "            res = (res*x) % mod;",
                "        y >>= 1;",
                "        x = (x*x) % mod;",
                "    }",
                "    return res; ",
                "}",
                "",
                "struct Hasher",
                "{",
                "    int p, mod;",
                "    string str;",
                "    vector<long> pws, mmi, prehash;",
                "",
                "    Hasher(string &s, int p, int m)",
                "    {",
                "        str = s;",
                "        mod = m;",
                "        int n = str.length();",
                "        long pm2 = modexp(p, mod-2, mod);",
                "        pws.reserve(n+1), mmi.reserve(n+1), prehash.reserve(n+1);",
                "        pws.push_back(1LL);",
                "        for(int i = 0; i < n; i++)",
                "            pws.push_back((p * pws.back()) % mod);",
                "        mmi.push_back(1LL);",
                "        for(int i = 0; i < n; i++)",
                "            mmi.push_back((pm2 * mmi.back()) % mod);",
                "        prehash.push_back(0LL);",
                "        for(int i = 0; i < n; i++)",
                "            prehash.push_back(((str[i]-'a'+1) * pws[i] + prehash.back()) % mod);",
                "    }",
                "",
                "    int hash(int l, int r)",
                "    {",
                "        return (((prehash[r+1] - prehash[l]) * mmi[l]) % mod + mod) % mod;",
                "    }",
                "};",
            ]
        },
        "KMP": {
            "prefix": "kmp",
            "body": [
                "vector<int> kmp_prefix(string &s)",
                "{",
                "    int n = s.length();",
                "    vector<int> pi(n);",
                "    for(int i = 1; i < n; ++i)",
                "    {",
                "        int j = pi[i-1];",
                "        while(j > 0 and s[i] != s[j])",
                "            j = pi[j-1];",
                "        if(s[i] == s[j])",
                "            j++;",
                "        pi[i] = j;",
                "    }",
                "    return pi;",
                "}",
                "",
                "vector<int> kmp(string &text, string &pattern)",
                "{",
                "    string con = pattern + '#' + text;",
                "    int m = text.size(), n = pattern.size();",
                "    vector<int> lps = kmp_prefix(con), v;",
                "    for(int i = n+1; i <= m+n; ++i)",
                "        if(lps[i] == n)",
                "            v.push_back(i - 2*n);",
                "    return v;",
                "}",
            ]
        },
        "Kruskal": {
            "prefix": "kruskal",
            "body": [
                "struct Edge",
                "{",
                "    int u, v, w;",
                "    Edge(int u, int v, int w)",
                "    {",
                "        this->u = u;",
                "        this->v = v;",
                "        this->w = w;",
                "    }",
                "    bool operator<(Edge const& e)",
                "    {",
                "        return w < e.w;",
                "    }",
                "};",
                "",
                "vector<Edge> kruskal(vector<Edge> edges, int n)",
                "{",
                "    DSU dsu(n);",
                "    vector<Edge> ans;",
                "    sort(edges.begin(), edges.end());",
                "    for(Edge [u, v, w] : edges)",
                "    {",
                "        if(dsu.root(u) != dsu.root(v))",
                "        {",
                "            ans.push_back({u, v, w});",
                "            dsu.merge(u, v);",
                "        }",
                "    }",
                "    return ans;",
                "}",
            ]
        },
        "Matrix": {
            "prefix": "matrix",
            "body": [
                "#define MOD (1000000007)",
                "#ifdef MOD",
                "#define SAFE_RED(a) (((a) % MOD + MOD) % MOD)",
                "#define RED(a)      ((a) % MOD)",
                "#define ADD(a, b)   RED((a) + (b))",
                "#define SUB(a, b)   ADD(RED((a) - (b)), MOD)",
                "#define MUL(a, b)   RED(((long) a) * (b))",
                "#define DIV(a, b)   MUL((a), modexp(b, MOD - 2))",
                "#define POW(a, b)   modexp(a, b)",
                "#define INC(a, b)   a = ADD(a, b)",
                "#define TIM(a, b)   a = MUL(a, b)",
                "#else",
                "#define SAFE_RED(a) (a)",
                "#define RED(a)      (a)",
                "#define ADD(a, b)   ((a) + (b))",
                "#define SUB(a, b)   ((a) - (b))",
                "#define MUL(a, b)   ((a) * (b))",
                "#define DIV(a, b)   ((a) / (b))",
                "#define POW(a, b)   long(pow(a, b))",
                "#define INC(a, b)   (a += b)",
                "#define TIM(a, b)   (a *= b)",
                "#endif",
                "",
                "long modexp(long x, long y)",
                "{",
                "    long res = 1;",
                "    x = SAFE_RED(x);",
                "    while (y)",
                "    {",
                "        if (y & 1)",
                "            TIM(res, x);",
                "        y >>= 1;",
                "        TIM(x, x);",
                "    }",
                "    return res;",
                "}",
                "",
                "struct Matrix",
                "{",
                "    vector<vector<long>> m;",
                "    int n;",
                "",
                "    Matrix(int size)",
                "    {",
                "        n = size;",
                "        m.resize(n);",
                "        for (auto& row : m)",
                "            row = vector<long>(n);",
                "    }",
                "",
                "    Matrix(Matrix& b)",
                "    {",
                "        n = b.size();",
                "        m = b.m;",
                "    }",
                "",
                "    int size()",
                "    {",
                "        return n;",
                "    }",
                "",
                "    void clear()",
                "    {",
                "        m = vector<vector<long>>(n, vector<long>(n));",
                "    }",
                "",
                "    long& at(int row, int col)",
                "    {",
                "        return m.at(row).at(col);",
                "    }",
                "",
                "    void make_identity()",
                "    {",
                "        clear();",
                "        for (int i = 0; i < n; ++i)",
                "            m.at(i).at(i) = 1;",
                "    }",
                "",
                "    vector<long>& operator [] (int row)",
                "    {",
                "        return m.at(row);",
                "    }",
                "",
                "    Matrix operator + (Matrix &b)",
                "    {",
                "        Matrix out(n);",
                "        for (int i = 0; i < n; ++i)",
                "            for (int j = 0; j < n; ++j)",
                "                out.at(i, j) = ADD(m.at(i).at(j), b.at(i, j));",
                "        return out;",
                "    }",
                "",
                "    Matrix operator * (Matrix &b)",
                "    {",
                "        Matrix out(n);",
                "        for (int i = 0; i < n; ++i)",
                "            for (int j = 0; j < n; ++j)",
                "                for (int k = 0; k < n; ++k)",
                "                    INC(out.at(i, j), MUL(m.at(i).at(k), b.at(k, j)));",
                "        return out;",
                "    }",
                "",
                "    friend ostream& operator << (ostream& out, Matrix b)",
                "    {",
                "        for (int i = 0; i < b.n; ++i)",
                "            for (int j = 0; j < b.n; ++j)",
                "                out << b.at(i, j) << \" \\n\"[j + 1 == b.n];",
                "        out << '\\n';",
                "        return out;",
                "    }",
                "",
                "    Matrix pow(int y)",
                "    {",
                "        Matrix a(*this), res(n);",
                "        res.make_identity();",
                "        while (y)",
                "        {",
                "            if (y & 1)",
                "                res = res * a;",
                "            y >>= 1;",
                "            a = a * a;",
                "        }",
                "        return res;",
                "    }",
                "};",
            ]
        },
        "Modular Arithmetic": {
            "prefix": "modarith",
            "body": [
                "#define MOD (1000000007)",
                "#ifdef MOD",
                "#define SAFE_RED(a) (((a) % MOD + MOD) % MOD)",
                "#define RED(a)      ((a) % MOD)",
                "#define ADD(a, b)   RED((a) + (b))",
                "#define SUB(a, b)   ADD(RED((a) - (b)), MOD)",
                "#define MUL(a, b)   RED(((long) a) * (b))",
                "#define DIV(a, b)   MUL((a), modexp(b, MOD - 2))",
                "#define POW(a, b)   modexp(a, b)",
                "#define INC(a, b)   a = ADD(a, b)",
                "#define TIM(a, b)   a = MUL(a, b)",
                "#else",
                "#define SAFE_RED(a) (a)",
                "#define RED(a)      (a)",
                "#define ADD(a, b)   ((a) + (b))",
                "#define SUB(a, b)   ((a) - (b))",
                "#define MUL(a, b)   ((a) * (b))",
                "#define DIV(a, b)   ((a) / (b))",
                "#define POW(a, b)   long(pow(a, b))",
                "#define INC(a, b)   (a += b)",
                "#define TIM(a, b)   (a *= b)",
                "#endif",
                "",
                "long modexp(long x, long y)",
                "{",
                "    long res = 1;",
                "    x = SAFE_RED(x);",
                "    while (y)",
                "    {",
                "        if (y & 1)",
                "            TIM(res, x);",
                "        y >>= 1;",
                "        TIM(x, x);",
                "    }",
                "    return res;",
                "}",
            ]
        },
        "Modular Exponentiation": {
            "prefix": "modexp",
            "body": [
                "long modexp(long x, long y, long mod = MOD)",
                "{",
                "    long res = 1;",
                "    x = (x % mod + mod) % mod;",
                "    while(y)",
                "    {",
                "        if(y & 1)",
                "            res = (res*x) % mod;",
                "        y >>= 1;",
                "        x = (x*x) % mod;",
                "    }",
                "    return res; ",
                "}",
            ]
        },
        "Next combination": {
            "prefix": "nextcomb",
            "body": [
                "bool next_combination(vector<int>& v, int n)",
                "{",
                "    int r = v.size(), i = 0;",
                "    v[i]++;",
                "    while (i < r and v[i] >= n-i)",
                "    {",
                "        if (++i == r)",
                "            return iota(v.rbegin(), v.rend(), 0), false;",
                "        v[i]++;",
                "    }",
                "    for (int j = 0; j < i; ++j)",
                "        v[j] = i - j + v[i];",
                "    return true;",
                "}",
            ]
        },
        "Primality test": {
            "prefix": "isprime",
            "body": [
                "bool is_prime(long n)",
                "{",
                "    if (n < 2)",
                "        return 0;",
                "    if (n < 4)",
                "        return 1;",
                "    if (n % 2 == 0 or n % 3 == 0)",
                "        return 0;",
                "    for (long i = 5; i * i <= n; i += 6)",
                "        if (n % i == 0 or n % (i + 2) == 0)",
                "            return 0;",
                "    return 1;",
                "}",
            ]
        },
        "Random Number Generator": {
            "prefix": "rng",
            "body": [
                "#define rn dist(rng)",
                "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
                "uniform_int_distribution<long> dist(1, ${1:n});",
            ]
        },
        "Smallest Prime Factor": {
            "prefix": "spf",
            "body": [
                "void sieve(int spf[M])",
                "{",
                "    for (int i = 2; i < M; ++i)",
                "        spf[i] = i;",
                "    for (int i = 2; i < M; ++i)",
                "    {",
                "        if(spf[i] != i)",
                "            continue;",
                "        for(int j = i + i; j < M; j += i)",
                "            spf[j] = i;",
                "    }",
                "}",
            ]
        },
        "Eratosthenes's Sieve": {
            "prefix": "sieve",
            "body": [
                "const int M = 10000020;"
                "bool comp[M];   // composite"
                ""
                "void sieve(bool comp[M])"
                "{"
                "    comp[0] = comp[1] = 1;"
                "    for (int i = 0; i*i < M; i++)"
                "    {"
                "        if (comp[i])"
                "            continue;"
                "        for (int j = i + i; j < M; j += i)"
                "            comp[j] = 1;"
                "    }"
                "}"
            ]
        },
        "Policy Based Data Structures": {
            "prefix": "pbtree",
            "body": [
                "#include <ext/pb_ds/assoc_container.hpp>",
                "#include <ext/pb_ds/tree_policy.hpp>",
                "using namespace __gnu_pbds;",
                "typedef tree<int, null_type, less<>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;",
                "// find_by_order, order_of_key",
            ]
        },
        "Unordered Map": {
            "prefix": "unorderedmap",
            "body": [
                "struct UnorderedMapHash",
                "{",
                "    static uint64_t splitmix64(uint64_t x)",
                "    {",
                "        x += 0x9e3779b97f4a7c15;",
                "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
                "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
                "        return x ^ (x >> 31);",
                "    }",
                "",
                "    size_t operator()(uint64_t x) const",
                "    {",
                "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
                "        return splitmix64(x + FIXED_RANDOM);",
                "    }",
                "};",
                "",
                "unordered_map<int, int, UnorderedMapHash> m;",
                "// m.reserve(1 << 20);",
                "// m.max_load_factor(0.25);",
            ]
        },
    
        // "temp": {
        //     "prefix": "temp",
        //     "body": [
        //         ""
        //     ]
        // },
    
        "fie": {"prefix": "fie", "body": "for (${3:i} = ${4:0}; ${3:i} < ${2:n}; ++${3:i})$1"},
        "fiei": {"prefix": "fiei", "body": "for (int ${3:i} = ${4:0}; ${3:i} < ${2:n}; ++${3:i})$1"},
        "fiii": {"prefix": "fiii", "body": "for (int ${3:i} = ${4:1}; ${3:i} <= ${2:n}; ++${3:i})$1"},
        "long": {"prefix": "ll", "body": "long"},
        "string": {"prefix": "sr", "body": "string"},
    
        "vector<int>": {"prefix": "vi", "body": "vector<int>"},
        "vector<long>": {"prefix": "vl", "body": "vector<long>"},
        "vector<char>": {"prefix": "vc", "body": "vector<char>"},
        "vector<bool>": {"prefix": "vb", "body": "vector<bool>"},
        "vector<string>": {"prefix": "vs", "body": "vector<string>"},
    
        "vector<vector<int>>": {"prefix": "vvi", "body": "vector<vector<int>>"},
        "vector<vector<long>>": {"prefix": "vvl", "body": "vector<vector<long>>"},
        "vector<vector<char>>": {"prefix": "vvc", "body": "vector<vector<char>>"},
        "vector<vector<string>>": {"prefix": "vvs", "body": "vector<vector<string>>"},
    
        "pair<int, int>": {"prefix": "pii", "body": "pair<int, int>"},
        "pair<long, long>": {"prefix": "pll", "body": "pair<long, long>"},
        "pair<char, char>": {"prefix": "pcc", "body": "pair<char, char>"},
        "pair<string, string>": {"prefix": "pss", "body": "pair<string, string>"},
        "pair<int, char>": {"prefix": "pic", "body": "pair<int, char>"},
        "pair<char, int>": {"prefix": "pci", "body": "pair<char, int>"},
        "pair<int, string>": {"prefix": "pis", "body": "pair<int, string>"},
        "pair<string, int>": {"prefix": "psi", "body": "pair<string, int>"},
    
        "pair<pair<int, int>, int>>": {"prefix": "ppiii", "body": "pair<pair<int, int>, int>>"},
        "pair<int, pair<int, int>>": {"prefix": "pipii", "body": "pair<int, pair<int, int>>"},
        "pair<pair<long, long>, long>>": {"prefix": "pplll", "body": "pair<pair<long, long>, long>>"},
        "pair<long, pair<long, long>>": {"prefix": "plpll", "body": "pair<long, pair<long, long>>"},
    
        "vector<pair<int, int>>": {"prefix": "vpii", "body": "vector<pair<int, int>>"},
        "vector<pair<long, long>>": {"prefix": "vpll", "body": "vector<pair<long, long>>"},
        
        "vector<pair<string, int>>": {"prefix": "vpsi", "body": "vector<pair<string, int>>"},
        "vector<pair<int, string>>": {"prefix": "vpis", "body": "vector<pair<int, string>>"},
    
        "vector<pair<pair<int, int>, int>>": {"prefix": "vppiii", "body": "vector<pair<pair<int, int>, int>>>"},
        "vector<pair<int, pair<int, int>>>": {"prefix": "vpipii", "body": "vector<pair<int, pair<int, int>>>"},
        "vector<pair<pair<long, long>, long>>>": {"prefix": "vpplll", "body": "vector<pair<pair<long, long>, long>>>"},
        "vector<pair<long, pair<long, long>>>": {"prefix": "vplpll", "body": "vector<pair<long, pair<long, long>>>"},
    
        "set<int>": {"prefix": "si", "body": "set<int>"},
        "set<long>": {"prefix": "sl", "body": "set<long>"},
        "set<char>": {"prefix": "sc", "body": "set<char>"},
        "set<string>": {"prefix": "ssr", "body": "set<string>"},
        "set<pair<int, int>>": {"prefix": "spii", "body": "set<pair<int, int>>"},
        "set<pair<long, long>>": {"prefix": "spll", "body": "set<pair<long, long>>"},
    
        "map<int, int>": {"prefix": "mii", "body": "map<int, int>"},
        "map<long, long>": {"prefix": "mll", "body": "map<long, long>"},
        "map<int, long>": {"prefix": "mil", "body": "map<int, long>"},
        "map<long, int>": {"prefix": "mli", "body": "map<long, int>"},
        "map<string, int>": {"prefix": "msi", "body": "map<string, int>"},
        "map<string, long>": {"prefix": "msl", "body": "map<string, long>"},
        "map<int, set<int>>": {"prefix": "misi", "body": "map<int, set<int>>"},
        "map<int, vector<int>>": {"prefix": "mivi", "body": "map<int, vector<int>>"},
        "map<pair<int, int>, int>": {"prefix": "mpiii", "body": "map<pair<int, int>, int>"},
        "map<int, pair<int, int>>": {"prefix": "mipii", "body": "map<int, pair<int, int>>"},
    
        "first": {"prefix": "ff", "body": "first"},
        "second": {"prefix": "ss", "body": "second"},
        "greater": {"prefix": "gr", "body": "greater<>"},
        "size": {"prefix": "sz", "body": "size()"},
        "push_back": {"prefix": "pb", "body": "push_back($1)"},
        "emplace_back": {"prefix": "eb", "body": "emplace_back($1)"},
        "push_front": {"prefix": "pf", "body": "push_front($1)"},
        "insert": {"prefix": "in", "body": "insert($1)"},
        "erase": {"prefix": "er", "body": "erase($1)"},
        "lower_bound": {"prefix": "lb", "body": "lower_bound($1)"},
        "upper_bound": {"prefix": "ub", "body": "upper_bound($1)"},
    
        "Declare array": {"prefix": "cn", "body": "const int N = ${1:3e5} + 5;"},
        "Modulo": {"prefix": "cmod", "body": "const int MOD = 1000000007;"},
        "Modulo2": {"prefix": "cmod2", "body": "const int MOD = 998244353;"},
        "Infinity": {"prefix": "cinf", "body": "const int INF = 0x3fffffff;"},
        "Infinity2": {"prefix": "cinf2", "body": "const long INF = (1LL << 62) - 1;"},
        "Pi": {"prefix": "cpi", "body": "const double PI = 3.1415926535898;"},
        "Epsilon": {"prefix": "ceps", "body": "const double EPS = 1e-8;"},
        "Max integer": {"prefix": "IM", "body": "INT_MAX"},
        "Max long": {"prefix": "LLM", "body": "LONG_LONG_MAX"},
    
        "newline": {"prefix": "nl", "body": "<< '\\n'"},
        "return": {"prefix": "ret", "body": "return"},
        "setprecision": {"prefix": "setprec", "body": "cout << fixed << setprecision(12)"},
        "Print runtime": {"prefix": "clock", "body": "cerr << \"\\nCompleted in \" << 1000 * clock() / CLOCKS_PER_SEC << \" ms\\n\";"},
        "Debug": {"prefix": "dbg", "body": "cerr << \"$1: \" << $1 << endl;"},
        "Meow": {"prefix": "meow", "body": "cerr << ${1:\"Meow\"} << endl;"},
        "popcount": {"prefix": "bpc", "body": "__builtin_popcountll($1)"},
        "popcount?": {"prefix": "bclz", "body": "__builtin_clzll($1)"},
        "First bit set": {"prefix": "bffs", "body": "__builtin_ffsll($1)"},
        "Ceiling division": {"prefix": "cdiv", "body": "$1/$2 + bool($1%$2)"},
        "floor": {"prefix": "floor", "body": "llround(floor($1))"},
        "ceil": {"prefix": "ceil", "body": "llround(ceil($1))"},
        "memset": {"prefix": "memset", "body": "memset($1, $2, sizeof($1));"},
        "cout and return": {"prefix": "rc", "body": "return cout << $1, 0;"},
        "Case #t:": {"prefix": "tcase", "body": "cout << \"Case #\" << t << \": \" << "},
    
        "Fast IO": {"prefix": "fastio", "body": "ios::sync_with_stdio(false), cin.tie(nullptr);"},
        "Begin End": {"prefix": "bend", "body": "$1.begin(), $1.end()"},
        "Yes/No": {"prefix": "yesno", "body": "cout << ($1 ? \"YES\" : \"NO\") << '\\n';"},
        "No/Yes": {"prefix": "noyes", "body": "cout << ($1 ? \"NO\" : \"YES\") << '\\n';"},
    }
}